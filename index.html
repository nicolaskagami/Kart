<html>

<head>
<title>Bruno Karttelan</title>
<script src="jquery-1.11.3.js"></script>
<script src="webgl-utils.js"></script>
<script src="webgl-3d-math.js"></script>
<script src="webgl-obj-loader.js"></script>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;
	varying vec4 vLightResult;
    uniform sampler2D uSampler;

    void main(void) {
		vec4 texelColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4(texelColor.rgb * vLightResult.rgb, texelColor.a);
    }
</script>
<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 a_position;
	attribute vec3 a_normal;
    attribute vec2 a_text_coord;
	
	uniform mat4 u_PMatrix;
	uniform mat4 u_MVMatrix;
	uniform mat4 u_normal_matrix;
	
	uniform float u_shininess;
	uniform vec3 u_light_direction;
	
	uniform vec4 u_ambient_light;
	uniform vec4 u_diffuse_light;
	uniform vec4 u_specular_light;
	
	uniform vec4 u_ambient_material;
	uniform vec4 u_diffuse_material;
	uniform vec4 u_specular_material;
	
	uniform bool u_use_light;
	

    varying vec2 vTextureCoord;
	varying vec4 vLightResult;


    void main(void) {
	
		vec4 vertexWorld = u_MVMatrix * vec4(a_position, 1.0);
		gl_Position = u_PMatrix * u_MVMatrix * vec4(a_position, 1.0);;
		vec3 transformedNormal = vec3(u_normal_matrix * vec4(a_normal, 0.0));
        vTextureCoord = a_text_coord;
		
		//Lighting
		if(u_use_light)
		{
			//vec3 pointLightDirection = normalize((u_MVMatrix * u_light_position) - vertexWorld.xyz);
			//vec3 L = pointLightDirection;
			vec3 vEyeVec = -vec3(vertexWorld.xyz);
			vec3 L = normalize(u_light_direction);
			vec3 N = normalize(transformedNormal);
			
			
			//Lambert's cosine law
			float lambertTerm = max(dot(N,-L),0.0);
			
			//Ambient Term
			vec4 Ia = u_ambient_light * u_ambient_material;
			
			//Diffuse Term
			vec4 Id = vec4(0.0,0.0,0.0,1.0);
		 
			//Specular Term
			vec4 Is = vec4(0.0,0.0,0.0,1.0);
			
			vLightResult = Ia;
			if(lambertTerm > 0.0) {
			    Id = u_diffuse_light * u_diffuse_material * lambertTerm;
				vec3 E = normalize(vEyeVec);
				vec3 R = reflect(-L, N);
				float specular = pow( max(dot(R, E), 0.0), u_shininess);
				Is = u_specular_light * u_specular_material * specular; //add specular term*/
				vLightResult += Id + Is;
			}
			vLightResult.a = 1.0;
		}
		else
		{
			vLightResult = vec4(1.0, 1.0, 1.0, 1.0);
		}
		
		
    }
</script>
<script type="text/javascript">
	
	//Variáveis Temp
	var time =0;

    //Variáveis gerais
    var models = {};
    var gl;
    var shaderProgram;
    var canvas;
    
    //Variáveis de Shader
    var shaderProgram;
        
    var positionLocation;
    var vertexNormalLocation;
    var textureLocation;

    var modelViewLocation;
    var projectionLocation;
    var normalMatrixLocation;
    var samplerLocation;

    var ambientLightLocation;
    var ambientMaterialLocation;
    var diffuseLightLocation;
    var diffuseMaterialLocation;
    var specularLightLocation;
    var specularMaterialLocation;
    var lightDirectionLocation;
    var shininessLocation;
    var useLightLocation;
    
    //Variáveis de Draw
    var projectionMatrix;
    var viewMatrix;
    var modelMatrix;
    
    var camPos;
    var camTarget;
    
    var lightDirection;
    
    var ambientLight;
    var diffuseLight;
    var specularLight;
    var shininess;
    
    var ambientMaterial;
    var diffuseMaterial;
    var specularMaterial;
    
    var lighting;
    var time_old;
    var angleToRotate;
    
    //Variáveis NEHE
    var neheTexture;
    
    
    //Funções matemáticas
    function radToDeg(r) {
        return r * 180 / Math.PI;
    }

    function degToRad(d) {
        return d * Math.PI / 180;
    }
    
    //Funções de inicialização
    function initGL(canvas) {
        gl = canvas.getContext("experimental-webgl");
        if (!gl) {
            alert("Could not initialise WebGL");
        }
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
        gl.enable(gl.DEPTH_TEST);
    }

    function initShaders() {
    
        shaderProgram = createProgramFromScripts(gl, ["shader-vs", "shader-fs"]);
        gl.useProgram(shaderProgram);// Tells which shaders we are going to use (we can have multiple shaders)
        
        positionLocation = gl.getAttribLocation(shaderProgram, "a_position");
        gl.enableVertexAttribArray(positionLocation);
        vertexNormalLocation = gl.getAttribLocation(shaderProgram, "a_normal");
        gl.enableVertexAttribArray(vertexNormalLocation);
        textureLocation = gl.getAttribLocation(shaderProgram, "a_text_coord");
        gl.enableVertexAttribArray(textureLocation);


        modelViewLocation = gl.getUniformLocation(shaderProgram, "u_MVMatrix");
        projectionLocation = gl.getUniformLocation(shaderProgram, "u_PMatrix");
        normalMatrixLocation = gl.getUniformLocation(shaderProgram, "u_normal_matrix");
        samplerLocation = gl.getUniformLocation(shaderProgram, "uSampler");

        ambientLightLocation = gl.getUniformLocation(shaderProgram, "u_ambient_light");
        ambientMaterialLocation = gl.getUniformLocation(shaderProgram, "u_ambient_material");
        diffuseLightLocation = gl.getUniformLocation(shaderProgram, "u_diffuse_light");
        diffuseMaterialLocation = gl.getUniformLocation(shaderProgram, "u_diffuse_material");
        specularLightLocation = gl.getUniformLocation(shaderProgram, "u_specular_light");
        specularMaterialLocation = gl.getUniformLocation(shaderProgram, "u_specular_material");
        lightDirectionLocation = gl.getUniformLocation(shaderProgram, "u_light_direction");
        shininessLocation = gl.getUniformLocation(shaderProgram, "u_shininess");
        useLightLocation = gl.getUniformLocation(shaderProgram, "u_use_light");
      
    }

    function initModels(meshes){
        models=meshes;
    }
    
    function handleLoadedTexture(texture) {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }    
    
    function initTexture(){
        neheTexture = gl.createTexture();
        neheTexture.image = new Image();
        neheTexture.image.onload = function () {
            handleLoadedTexture(neheTexture)
        }
        //neheTexture.image.crossOrigin = "Anonymous";
        neheTexture.image.src = "modelText.jpg";
    }

    function initDrawingParameters(){
        projectionMatrix = makeIdentity();
        viewMatrix = makeIdentity();
        modelMatrix = makeIdentity();
        
        camPos = [0,0,-4];
        camTarget = [0,0,0];
        
        lightDirection = [0,0,0];
        
        ambientLight = [1,1,1,0];
        diffuseLight = [0,0,0,0];
        specularLight = [0,0,0,0];
        shininess = 180.0;
        
        ambientMaterial = [1,1,1,0];
        diffuseMaterial = [0,0,0,0];
        specularMaterial = [0,0,0,0];
        
        lighting = false;
        
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clearDepth(1.0);
        time_old=0;
        angleToRotate=0;
    
        OBJ.initMeshBuffers(gl, models.mario);
        OBJ.initMeshBuffers(gl, models.track);
    }
    
    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    }
    
    
    //Funções do Game loop
    function draw(time) {
        console.log("Drawing");

        gl.viewport(0.0, 0.0, canvas.clientWidth, canvas.clientHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
        //Getting the inputs for lights
        //getTextInput();
        
        // Definition of our projection and camera matrix and sending to the vertex shader
        projectionMatrix = makePerspective(degToRad(60), 
                  canvas.clientWidth / canvas.clientHeight, 1, 2000);
        gl.uniformMatrix4fv(projectionLocation, false, projectionMatrix);
        
        // Definition of our camera matrix
        viewMatrix = makeLookAt(
          camPos, //Camera position
          camTarget, //Target
          [0,1,0] //Up Vector
        );
        
        // Rotation of the object
        var dt=time-time_old;
        modelMatrix = makeIdentity();
        angleToRotate+=dt*0.002;
        modelMatrix = matrixMultiply(modelMatrix, makeYRotation(angleToRotate));
        time_old = time;
        
        
        // Multiplying model and camera matrix to send to the vertex buffer
        var modelView = matrixMultiply(modelMatrix,viewMatrix);
        gl.uniformMatrix4fv(modelViewLocation, false, modelView);
        
        //  Sending the normal matrix to the vertex shader (since we are transforming our vertex,
        // the normals need to transform together, but maintaining perpendicularity with the triangle)
        // Explanation of this matrix too advanced to our context, but if you want to understand better,
        // read this article: http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix/
        var normalMatrix = makeTranspose(makeInverse(modelView));
        gl.uniformMatrix4fv(normalMatrixLocation, false, normalMatrix);
        
        /*
            Sending light values to the shaders
        */
        gl.uniform1i(useLightLocation, lighting);
        
        gl.uniform3fv(lightDirectionLocation, lightDirection);
        
        gl.uniform4fv(ambientLightLocation, ambientLight);
        gl.uniform4fv(diffuseLightLocation, diffuseLight);
        gl.uniform4fv(specularLightLocation, specularLight);
        gl.uniform1f(shininessLocation, shininess);
        
        gl.uniform4fv(ambientMaterialLocation, ambientMaterial);
        gl.uniform4fv(diffuseMaterialLocation, diffuseMaterial);
        gl.uniform4fv(specularMaterialLocation, specularMaterial);
        
        /*
            Sending the buffers to the shaders
        */
        /*
            Drawing Mario model
        */
        gl.bindBuffer(gl.ARRAY_BUFFER, models.mario.vertexBuffer);
        gl.vertexAttribPointer(positionLocation, models.mario.vertexBuffer.itemSize, gl.FLOAT, false, 0,0);
        
        if(!models.mario.textures.length){
            gl.disableVertexAttribArray(textureLocation);
        }
        else{
            gl.enableVertexAttribArray(textureLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, models.mario.textureBuffer);
            gl.vertexAttribPointer(textureLocation, models.mario.textureBuffer.itemSize, gl.FLOAT, false, 0,0);
        }
        
        if(!models.mario.vertexNormals.length){
            gl.disableVertexAttribArray(vertexNormalLocation);
        }
        else{
            gl.enableVertexAttribArray(vertexNormalLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, models.mario.normalBuffer);
            gl.vertexAttribPointer(vertexNormalLocation, models.mario.normalBuffer.itemSize, gl.FLOAT, false, 0,0);
        }

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, neheTexture);
        gl.uniform1i(samplerLocation, 0);
        
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, models.mario.indexBuffer);
        gl.drawElements(gl.TRIANGLES, models.mario.indices.length, gl.UNSIGNED_SHORT, 0);
        
        /*
            Drawing the track
        */    
        gl.bindBuffer(gl.ARRAY_BUFFER, models.track.vertexBuffer);
        gl.vertexAttribPointer(positionLocation, models.track.vertexBuffer.itemSize, gl.FLOAT, false, 0,0);
        
        if(!models.track.textures.length){
            gl.disableVertexAttribArray(textureLocation);
        }
        else{
            gl.enableVertexAttribArray(textureLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, models.track.textureBuffer);
            gl.vertexAttribPointer(textureLocation, models.track.textureBuffer.itemSize, gl.FLOAT, false, 0,0);
        }
        
        if(!models.track.vertexNormals.length){
            gl.disableVertexAttribArray(vertexNormalLocation);
        }
        else{
            gl.enableVertexAttribArray(vertexNormalLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, models.track.normalBuffer);
            gl.vertexAttribPointer(vertexNormalLocation, models.track.normalBuffer.itemSize, gl.FLOAT, false, 0,0);
        }

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, neheTexture);
        gl.uniform1i(samplerLocation, 0);
        

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, models.track.indexBuffer);
        gl.drawElements(gl.TRIANGLES, models.track.indices.length, gl.UNSIGNED_SHORT, 0);
        
    
    }

    function update()
    {
        console.log(time);
    }
    
    function gameLoop()
    {
        update();
        draw(time);
        requestAnimationFrame(gameLoop);
		time+=10;
    }

    function init(meshes) {
        canvas = document.getElementById("Karttelan-canvas");
        initGL(canvas);
        initShaders();
        initModels(meshes);
        initTexture();
        initDrawingParameters();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

		time =0;
        gameLoop();
    }

    window.onload = function(){
        OBJ.downloadMeshes({
            'mario': 'models/Mario/mk_kart.obj',
            'track': 'models/Pista/raceway_mariokart.obj'
    }, init);
}
</script>

</head>

<body>
        <h4>Kartellanister</h4>
        <div id="section">
              <canvas id="Karttelan-canvas" style="border: none;" width="640" height="640"></canvas>
        </div>
</body>
